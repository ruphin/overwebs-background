{"version":3,"sources":["overwebs-background.js"],"names":["GluonElement","html","OverwebsBackground","template","properties","backgrounds","type","Object","observer","lowBandwidth","Boolean","value","page","String","observedAttributes","attributeChangedCallback","_page","_pageChanged","_backgrounds","_backgroundElements","remove","mirror","document","createElement","videoSource","video","posterSource","image","playsInline","preload","loop","transition","id","classList","add","shadowRoot","appendChild","console","warn","_transition","_currentlyShowing","_stop","removeEventListener","_endedListener","paused","pause","currentTime","poster","src","load","play","concat","map","forEach","addEventListener","customElements","define","is"],"mappings":"AAAA,OAASA,YAAT,CAAuBC,IAAvB,KAAmC,qBAAnC,CAEA,KAAMC,mBAAN,QAAiCF,aAAa,CAC5C,GAAIG,SAAJ,EAAe,CACb,MAAOF,KAAK;;;;;;;;;;;;;;;;aAiBb,CAED,UAAWG,WAAX,EAAwB,CACtB,MAAO,CACLC,YAAa,CACXC,KAAMC,MADK,CAEXC,SAAU,iBAFC,CADR,CAKLC,aAAc,CACZH,KAAMI,OADM,CAEZC,QAFY,CALT,CASLC,KAAM,CACJN,KAAMO,MADF,CAEJL,SAAU,cAFN,CATD,CAcR,CAED,UAAWM,mBAAX,EAAgC,CAC9B,8BACD,CAEDC,+BAAmD,CACpC,eAAT,IAD6C,GAE/C,KAAKN,YAAL,EAF+C,EAIpC,MAAT,IAJ6C,GAK/C,KAAKG,IAAL,EAL+C,CAOlD,CAED,GAAIA,KAAJ,GAAe,CACT,IAAS,KAAKI,KADL,GAEX,KAAKC,YAAL,GAAwB,KAAKD,KAA7B,CAFW,CAGX,KAAKA,KAAL,EAHW,CAKd,CAED,GAAIJ,KAAJ,EAAW,CACT,MAAO,MAAKI,KACb,CAED,GAAIX,YAAJ,GAA6B,CAC3B,GAAI,IAAgB,KAAKa,YAAzB,CAAuC,CAGrC,GAFA,KAAKA,YAAL,EAEA,CAAI,KAAKC,mBAAT,CACE,IAAK,GAAI,EAAT,GAAyB,MAAKA,mBAA9B,CAEE,KAAKA,mBAAL,KAA0C,KAAKA,mBAAL,IAAuCC,MAAvC,EAA1C,CAOJ,IAAK,GAAI,EAAT,GAHA,MAAKD,mBAAL,GAGA,GACE,GAAI,CAAC,KAAqBE,MAA1B,CAAkC,CAChC,GAAI,GAAQC,SAASC,aAAT,CAAuB,OAAvB,CAAZ,CACA,EAAMC,WAAN,CAAoB,KAAqBC,KAArB,QAFY,CAGhC,EAAMC,YAAN,CAAqB,KAAqBC,KAHV,CAIhC,EAAMC,WAAN,GAJgC,CAKhC,EAAMC,OAAN,CAAgB,MALgB,CAMhC,EAAMC,IAAN,CAAa,CAAC,KAAqBC,UANH,CAOhC,EAAMC,EAAN,EAPgC,CAQhC,EAAMC,SAAN,CAAgBC,GAAhB,CAAoB,QAApB,CARgC,CAShC,KAAKC,UAAL,CAAgBC,WAAhB,GATgC,CAUhC,KAAKjB,mBAAL,KACD,CAGH,IAAK,GAAI,EAAT,MACM,KAAqBE,MAD3B,GAEI,KAAKF,mBAAL,IAAoC,KAAKA,mBAAL,CAAyB,KAAqBE,MAA9C,CAFxC,EAMA,KAAKJ,YAAL,CAAkB,KAAKL,IAAvB,CACD,CACF,CAED,GAAIP,YAAJ,EAAkB,CAChB,MAAO,MAAKa,YACb,CAEDD,iBAA+B,CAC7B,GAAI,CAAC,KAAKZ,WAAN,EAAqB,CAAC,KAAKc,mBAA/B,CAEE,WADAkB,SAAQC,IAAR,CAAa,uEAAb,CACA,CAGF,MAKA,EAAU,GAAW,EALrB,CASA,GAAI,GAAgB,KAAKnB,mBAAL,CAAyB,EAAU,MAAV,EAAzB,GAAwD,KAAKA,mBAAL,CAAyB,OAAzB,CAAxD,EAAqG,KAAKA,mBAAL,GAAzH,CATA,EAYE,KAAKoB,WAAL,GAZF,EAcEF,QAAQC,IAAR,CAAa,6BAAb,CAdF,CAeM,KAAKE,iBAfX,EAgBI,KAAKC,KAAL,CAAW,KAAKD,iBAAhB,CAhBJ,EAmBD,CAIDC,QAAe,CACb,EAAQR,SAAR,CAAkBC,GAAlB,CAAsB,QAAtB,CADa,CAEb,EAAQQ,mBAAR,CAA4B,OAA5B,CAAqC,KAAKC,cAA1C,CAFa,CAGR,EAAQC,MAHA,EAIX,EAAQC,KAAR,EAJW,CAMb,EAAQC,WAAR,CAAsB,CACvB,CAGDP,cAAoB,CAElB,GAAI,KAAK9B,YAAL,EAAqB,KAAKJ,WAAL,CAAiB,EAAO2B,EAAxB,EAA4BD,UAArD,CAEE,WADA,MAAKQ,WAAL,CAAiB,KAAKpB,mBAAL,CAAyB,KAAKd,WAAL,CAAiB,EAAO2B,EAAxB,EAA4BD,UAArD,CAAjB,CACA,CAIF,EAAOgB,MAAP,CAAgB,EAAOrB,YARL,CASlB,EAAOO,SAAP,CAAiBb,MAAjB,CAAwB,QAAxB,CATkB,CAYd,KAAKoB,iBAAL,EAA0B,IAAW,KAAKA,iBAZ5B,EAahB,KAAKC,KAAL,CAAW,KAAKD,iBAAhB,CAbgB,CAiBb,KAAK/B,YAAN,EAAsB,EAAOe,WAAP,SAjBR,GAmBO,MAAnB,KAAOK,OAnBK,GAoBd,EAAOmB,GAAP,CAAa,EAAOxB,WApBN,CAqBd,EAAOK,OAAP,CAAiB,MArBH,CAsBd,EAAOoB,IAAP,EAtBc,EAwBhB,EAAOC,IAAP,EAxBgB,EA4BlB,KAAKV,iBAAL,EA5BkB,CA+BlB,GAAI,KAAJ,CACI,KAAKnC,WAAL,CAAiB,EAAO2B,EAAxB,EAA4BD,UAhCd,GAiChB,EAAiB,EAAeoB,MAAf,CAAsB,KAAK9C,WAAL,CAAiB,EAAO2B,EAAxB,EAA4BD,UAAlD,CAjCD,EAmCd,KAAK1B,WAAL,CAAiB,EAAO2B,EAAxB,EAA4BH,OAnCd,GAoChB,EAAiB,EAAesB,MAAf,CAAsB,KAAK9C,WAAL,CAAiB,EAAO2B,EAAxB,EAA4BH,OAAlD,CApCD,EAsClB,EAAiB,EAAeuB,GAAf,CAAmB,KAC3B,KAAKjC,mBAAL,GADQ,CAtCC,CA4ClB,EAAekC,OAAf,CAAuB,KAAU,CAC/B,GAAI,KAAK5C,YAAT,MAES,KAAKJ,WAAL,CAAiB,EAAO2B,EAAxB,EAA4BD,UAFrC,EAGI,EAAS,KAAKZ,mBAAL,CAAyB,KAAKd,WAAL,CAAiB,EAAO2B,EAAxB,EAA4BD,UAArD,CAAT,CAHJ,IAMyB,MAAnB,KAAOF,OANb,GAOI,EAAOmB,GAAP,CAAa,EAAOxB,WAPxB,CAQI,EAAOK,OAAP,CAAiB,MARrB,EAgBI,EAAOH,YAjBoB,GAkB7B,EAAOqB,MAAP,CAAgB,EAAOrB,YAlBM,CAoBhC,CApBD,CA5CkB,CAmEd,KAAKrB,WAAL,CAAiB,EAAO2B,EAAxB,EAA4BD,UAnEd,GAoEhB,KAAKY,cAAL,CAAsB,IAAM,CAC1B,KAAKJ,WAAL,CAAiB,KAAKpB,mBAAL,CAAyB,KAAKd,WAAL,CAAiB,EAAO2B,EAAxB,EAA4BD,UAArD,CAAjB,CACD,CAtEe,CAuEhB,EAAOuB,gBAAP,CAAwB,OAAxB,CAAiC,KAAKX,cAAtC,CAvEgB,CAyEnB,CAzN2C,CA4N9CY,eAAeC,MAAf,CAAsBtD,mBAAmBuD,EAAzC,CAA6CvD,kBAA7C,C","file":"overwebs-background.js","sourcesContent":["import { GluonElement, html } from '../gluonjs/gluon.js';\n\nclass OverwebsBackground extends GluonElement {\n  get template() {\n    return html`\n    <style>\n    video {\n      position: fixed;\n      top: 50%;\n      left: 50%;\n      min-width: 100%;\n      min-height: 100%;\n      width: calc(16/9*100vh);\n      height: auto;\n      -webkit-transform: translateX(-50%) translateY(-50%);\n      transform: translateX(-50%) translateY(-50%);\n    }\n    video.hidden {\n      display: none;\n    }\n    </style>`;\n  }\n\n  static get properties() {\n    return {\n      backgrounds: {\n        type: Object,\n        observer: '_setBackgrounds'\n      },\n      lowBandwidth: {\n        type: Boolean,\n        value: false\n      },\n      page: {\n        type: String,\n        observer: '_pageChanged'\n      }\n    };\n  }\n\n  static get observedAttributes() {\n    return ['low-bandwidth', 'page'];\n  }\n\n  attributeChangedCallback(attr, oldValue, newValue) {\n    if (attr === 'low-bandwidth') {\n      this.lowBandwidth = newValue;\n    }\n    if (attr === 'page') {\n      this.page = newValue;\n    }\n  }\n\n  set page(page) {\n    if (page !== this._page) {\n      this._pageChanged(page, this._page);\n      this._page = page;\n    }\n  }\n\n  get page() {\n    return this._page;\n  }\n\n  set backgrounds(backgrounds) {\n    if (backgrounds !== this._backgrounds) {\n      this._backgrounds = backgrounds;\n      // Remove existing backgroundElements\n      if (this._backgroundElements) {\n        for (let videoElement in this._backgroundElements) {\n          // We need to check if the element exists, because one backgroundElement can mirror another, so it may already be removed.\n          this._backgroundElements[videoElement] && this._backgroundElements[videoElement].remove();\n        }\n      }\n\n      this._backgroundElements = {};\n\n      // Create a video element for each background video from the dataset\n      for (let section in backgrounds) {\n        if (!backgrounds[section].mirror) {\n          let video = document.createElement('video');\n          video.videoSource = backgrounds[section].video || undefined;\n          video.posterSource = backgrounds[section].image;\n          video.playsInline = true;\n          video.preload = 'none';\n          video.loop = !backgrounds[section].transition;\n          video.id = section;\n          video.classList.add('hidden');\n          this.shadowRoot.appendChild(video);\n          this._backgroundElements[section] = video;\n        }\n      }\n      // Let the backgrounds that simply mirror an existing background use that element\n      for (let section in backgrounds) {\n        if (backgrounds[section].mirror) {\n          this._backgroundElements[section] = this._backgroundElements[backgrounds[section].mirror];\n        }\n      }\n\n      this._pageChanged(this.page);\n    }\n  }\n\n  get backgrounds() {\n    return this._backgrounds;\n  }\n\n  _pageChanged(newPage, oldPage) {\n    if (!this.backgrounds || !this._backgroundElements) {\n      console.warn('Attempting to load page background, but background data is not loaded');\n      return;\n    }\n\n    if (!newPage) {\n      return;\n    }\n\n    // If oldPage is falsy, replace it with emptystring\n    oldPage = oldPage || '';\n\n    // The goal is to have it decide automatically what background to use, based on the previous page and new page.\n    // It should attempt to find 'previous_to_next', then 'to_next', then 'next', in order.\n    let newBackground = this._backgroundElements[oldPage + '_to_' + newPage] || this._backgroundElements['to_' + newPage] || this._backgroundElements[newPage];\n\n    if (newBackground) {\n      this._transition(newBackground);\n    } else {\n      console.warn('Page has no background data');\n      if (this._currentlyShowing) {\n        this._stop(this._currentlyShowing);\n      }\n    }\n  }\n\n  // Stop and hide the given video element.\n  // Also remove any pending transitions.\n  _stop(element) {\n    element.classList.add('hidden');\n    element.removeEventListener('ended', this._endedListener);\n    if (!element.paused) {\n      element.pause();\n    }\n    element.currentTime = 0;\n  }\n\n  // This is all good\n  _transition(target) {\n    // If we are on low bandwith mode, skip transitions\n    if (this.lowBandwidth && this.backgrounds[target.id].transition) {\n      this._transition(this._backgroundElements[this.backgrounds[target.id].transition]);\n      return;\n    }\n\n    // Show the new background\n    target.poster = target.posterSource;\n    target.classList.remove('hidden');\n\n    // Hide whatever we were previously showing\n    if (this._currentlyShowing && target !== this._currentlyShowing) {\n      this._stop(this._currentlyShowing);\n    }\n\n    // If we're not low bandwidth mode, start playing\n    if (!this.lowBandwidth && target.videoSource !== undefined) {\n      // Start loading the video immediately if it wasn't already loading\n      if (target.preload !== 'auto') {\n        target.src = target.videoSource;\n        target.preload = 'auto';\n        target.load();\n      }\n      target.play();\n    }\n\n    // Update what we're currently showing\n    this._currentlyShowing = target;\n\n    // Set up a list of elements that should be preloaded\n    let preloadTargets = [];\n    if (this.backgrounds[target.id].transition) {\n      preloadTargets = preloadTargets.concat(this.backgrounds[target.id].transition);\n    }\n    if (this.backgrounds[target.id].preload) {\n      preloadTargets = preloadTargets.concat(this.backgrounds[target.id].preload);\n    }\n    preloadTargets = preloadTargets.map(preloadTarget => {\n      return this._backgroundElements[preloadTarget];\n    });\n\n    // On low bandwidth, skip preloading video, and  we only need images\n    // for things that don't have transitions.\n    preloadTargets.forEach(target => {\n      if (this.lowBandwidth) {\n        // Find the last element in the transition chain\n        while (this.backgrounds[target.id].transition) {\n          target = this._backgroundElements[this.backgrounds[target.id].transition];\n        }\n      } else {\n        if (target.preload !== 'auto') {\n          target.src = target.videoSource;\n          target.preload = 'auto';\n        }\n        // I don't know why this was here, it doesn't make any sense to me:\n        // // This is required for looping. If a video ends,\n        // // the 'src' attribute is cleared\n        // target.src = target.videoSource\n      }\n\n      if (target.posterSource) {\n        target.poster = target.posterSource;\n      }\n    });\n\n    // Either set up a transition to the next section, or enable looping on the current video\n    if (this.backgrounds[target.id].transition) {\n      this._endedListener = () => {\n        this._transition(this._backgroundElements[this.backgrounds[target.id].transition]);\n      };\n      target.addEventListener('ended', this._endedListener);\n    }\n  }\n}\n\ncustomElements.define(OverwebsBackground.is, OverwebsBackground);\n"]}